"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
var constant_1 = require("./constant");
var index_1 = require("./geo/index");
var index_2 = require("./serverDate/index");
var Util = (function () {
    function Util() {
    }
    Util.formatResDocumentData = function (documents) {
        return documents.map(function (document) {
            return Util.formatField(document);
        });
    };
    Util.formatField = function (document) {
        var keys = Object.keys(document);
        var protoField = {};
        if (Array.isArray(document)) {
            protoField = [];
        }
        keys.forEach(function (key) {
            var item = document[key];
            var type = Util.whichType(item);
            var realValue;
            switch (type) {
                case constant_1.FieldType.GeoPoint:
                    realValue = new index_1.Point(item.coordinates[0], item.coordinates[1]);
                    break;
                case constant_1.FieldType.GeoLineString:
                    realValue = new index_1.LineString(item.coordinates.map(function (point) { return new index_1.Point(point[0], point[1]); }));
                    break;
                case constant_1.FieldType.GeoPolygon:
                    realValue = new index_1.Polygon(item.coordinates.map(function (line) { return new index_1.LineString(line.map(function (_a) {
                        var _b = __read(_a, 2), lng = _b[0], lat = _b[1];
                        return new index_1.Point(lng, lat);
                    })); }));
                    break;
                case constant_1.FieldType.GeoMultiPoint:
                    realValue = new index_1.MultiPoint(item.coordinates.map(function (point) { return new index_1.Point(point[0], point[1]); }));
                    break;
                case constant_1.FieldType.GeoMultiLineString:
                    realValue = new index_1.MultiLineString(item.coordinates.map(function (line) { return new index_1.LineString(line.map(function (_a) {
                        var _b = __read(_a, 2), lng = _b[0], lat = _b[1];
                        return new index_1.Point(lng, lat);
                    })); }));
                    break;
                case constant_1.FieldType.GeoMultiPolygon:
                    realValue = new index_1.MultiPolygon(item.coordinates.map(function (polygon) {
                        return new index_1.Polygon(polygon.map(function (line) { return new index_1.LineString(line.map(function (_a) {
                            var _b = __read(_a, 2), lng = _b[0], lat = _b[1];
                            return new index_1.Point(lng, lat);
                        })); }));
                    }));
                    break;
                case constant_1.FieldType.Timestamp:
                    realValue = new Date(item.$timestamp * 1000);
                    break;
                case constant_1.FieldType.Object:
                case constant_1.FieldType.Array:
                    realValue = Util.formatField(item);
                    break;
                case constant_1.FieldType.ServerDate:
                    realValue = new Date(item.$date);
                    break;
                default:
                    realValue = item;
            }
            if (Array.isArray(protoField)) {
                protoField.push(realValue);
            }
            else {
                protoField[key] = realValue;
            }
        });
        return protoField;
    };
    Util.whichType = function (obj) {
        var type = Object.prototype.toString.call(obj).slice(8, -1);
        if (type === constant_1.FieldType.Timestamp) {
            return constant_1.FieldType.BsonDate;
        }
        if (type === constant_1.FieldType.Object) {
            if (obj instanceof index_1.Point) {
                return constant_1.FieldType.GeoPoint;
            }
            else if (obj instanceof Date) {
                return constant_1.FieldType.Timestamp;
            }
            else if (obj instanceof index_2.ServerDate) {
                return constant_1.FieldType.ServerDate;
            }
            if (obj.$timestamp) {
                type = constant_1.FieldType.Timestamp;
            }
            else if (obj.$date) {
                type = constant_1.FieldType.ServerDate;
            }
            else if (index_1.Point.validate(obj)) {
                type = constant_1.FieldType.GeoPoint;
            }
            else if (index_1.LineString.validate(obj)) {
                type = constant_1.FieldType.GeoLineString;
            }
            else if (index_1.Polygon.validate(obj)) {
                type = constant_1.FieldType.GeoPolygon;
            }
            else if (index_1.MultiPoint.validate(obj)) {
                type = constant_1.FieldType.GeoMultiPoint;
            }
            else if (index_1.MultiLineString.validate(obj)) {
                type = constant_1.FieldType.GeoMultiLineString;
            }
            else if (index_1.MultiPolygon.validate(obj)) {
                type = constant_1.FieldType.GeoMultiPolygon;
            }
        }
        return type;
    };
    Util.generateDocId = function () {
        var chars = 'ABCDEFabcdef0123456789';
        var autoId = '';
        for (var i = 0; i < 24; i++) {
            autoId += chars.charAt(Math.floor(Math.random() * chars.length));
        }
        return autoId;
    };
    return Util;
}());
exports.Util = Util;
